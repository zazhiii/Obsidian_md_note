## 大致实现
实现题目测评系统的核心步骤通常包括题目编译、运行环境管理、测试数据校验以及结果判定。以下是具体的步骤：

1. **题目编译和环境设置**：
   - **编译器和语言支持**：确保支持题目规定的编程语言（如C/C++、Python等），可以使用JDK、GCC等编译器。
   - **编译命令生成**：根据提交的代码语言生成不同的编译命令，例如 `gcc` 处理C/C++代码，`javac` 处理Java代码。
   - **编译结果处理**：捕获编译过程中的错误或警告信息。如果编译成功，生成可执行文件；如果失败，记录编译错误信息返回给用户。

2. **测试用例准备**：
   - **测试用例存储**：将每个题目的输入和输出测试数据存储在数据库或文件系统中。
   - **输入输出文件格式**：每个题目需要一组或多组测试输入文件和预期输出文件，命名规则需一致，便于自动匹配。

3. **程序执行与沙盒隔离**：
   - **沙盒环境**：为每个执行代码提供一个隔离的环境，可以使用Docker或Cgroups等实现资源限制和环境隔离，确保提交代码不会影响系统的其他部分。
   - **执行命令**：将编译生成的可执行文件与输入文件关联并执行，捕获程序输出和错误输出。
   - **资源限制**：控制程序的CPU时间、内存、栈大小等，防止资源消耗过高导致系统崩溃。

4. **结果判定**：
   - **运行超时检测**：如果运行时间超过题目规定的时间限制，判定为超时错误。
   - **内存溢出检测**：如果消耗内存超过限制，判定为内存错误。
   - **正确性检测**：将程序输出与预期输出文件逐行比较，若完全匹配，判定为正确，否则记录不同点作为错误输出。

5. **结果返回与记录**：
   - **结果反馈**：将测评结果（如正确、超时、内存超限、运行错误等）返回给前端。
   - **记录保存**：将测评结果和过程中的重要日志记录到数据库，便于日后查阅和统计。

6. **并发处理**：
   - **多队列调度**：建立任务队列，使用并发或异步任务调度处理多用户提交的请求。
   - **负载均衡**：合理分配测评任务到不同的计算节点上，优化系统的测评效率。

可以先实现简易版本，例如只支持少数几种语言、基本的测试数据，之后逐步扩展，加入更多的判定逻辑和容错机制，以提高系统的稳定性和扩展性。

---


## 实现
### 1. 系统初始化与编译配置

**1.1 环境准备**
   - 安装不同编程语言的编译器，比如`gcc`（C/C++）、`javac`（Java）、`python3`（Python）。
   - 安装Docker或其它沙盒工具，用于隔离代码执行环境，避免恶意代码影响服务器。

**1.2 题目存储设计**
   - 在数据库中创建题目表和测试用例表，用于保存题目信息和输入、输出数据。例如：
### 2. 用户提交代码的处理

**2.1 接收并存储用户代码**
   - 创建一个`submissions`表，用于保存用户提交信息和测评结果。
### 3. 异步处理代码编译和运行

### 4. 沙盒中运行测试用例

**4.1 设置资源限制**
   - 通过Docker或其他沙盒工具来限制运行的时间和内存。

**4.2 逐个测试用例执行**
   - 遍历所有测试用例，输入数据文件路径，通过管道传递给程序，获取输出并比对。

### 5. 结果判定与反馈

**5.1 检查异常状态**
   - 通过进程的`exitCode`判断异常状态，例如超时或内存溢出，记录错误。

**5.2 更新测评状态**
   - 对每个测试用例的状态，更新数据库中的记录。
**5.3 返回结果**
   - 完成测评后，将结果反馈给用户，通过WebSocket或前端轮询显示最终测评状态。

### 6. 并发处理与任务调度

**6.1 创建任务队列**
   - 可以采用消息队列（如RabbitMQ、Kafka）或使用线程池处理并发的测评任务。

**6.2 调度与负载均衡**
   - 将任务分配给多个测评节点，确保系统稳定性。

---
在判题系统中，判题服务器和后端服务器承担不同的角色，各自负责的具体功能如下：

### 1. **后端服务器**

后端服务器的主要职责是处理用户的请求，并管理整个判题过程。具体功能如下：

- **用户认证和授权**：管理用户登录、权限控制，确保只有经过授权的用户可以访问特定资源。
  
- **题目管理**：
  - 提供题目的增删改查 (CRUD) 接口，供管理员和普通用户使用。
  - 支持多样题目类型，比如选择题、编程题等。

- **判题请求处理**：
  - 接收用户提交的代码和相关的题目信息。
  - 将提交的代码、语言、用户信息等包装成判题请求，并传递到消息队列。
  - 生成判题任务唯一标识符 (ID)，便于后续查询判题结果。

- **任务状态查询**：
  - 根据判题任务的唯一 ID 查询判题状态（例如：正在判题、判题成功、判题失败）。
  - 提供判题结果查询接口，供前端实时获取最新的判题状态和结果。

- **结果存储与管理**：
  - 将判题结果（如通过的测试用例数量、编译错误信息、运行错误等）保存到数据库中。
  - 存储判题历史记录，以便用户查询自己的提交记录，管理员查看系统判题情况。

- **队列管理**（可选）：
  - 监控消息队列中的任务量，以应对高峰请求。
  - 在消息队列堆积严重时，触发通知或自动扩展判题服务器实例以分担负载。

### 2. **判题服务器**

判题服务器负责实际的代码编译、执行以及判题过程，通常需要高性能和安全隔离。具体功能如下：

- **任务监听与接收**：
  - 从消息队列中监听并接收判题任务。
  - 根据任务内容获取用户代码、题目数据和判题配置。

- **代码编译**：
  - 根据不同的编程语言，对用户代码进行编译（如 C++ 编译器 `g++`，Java 编译器 `javac` 等）。
  - 捕获编译过程中的错误或警告，将编译结果反馈给后端服务器。

- **沙盒执行**：
  - 使用 Docker 或 isolate 等沙盒工具，在隔离环境中执行用户代码，确保代码运行不会影响判题服务器本身的安全和性能。
  - 设置沙盒的资源限制（CPU、内存、运行时间、栈大小等），防止用户代码引发系统资源消耗过高。

- **测试数据管理**：
  - 根据题目要求，获取对应的测试用例和输入数据。
  - 将测试数据传入用户程序，捕获程序的输出，比较输出与预期答案。

- **判题结果生成**：
  - 根据测试结果生成判题报告，包括通过的测试用例数、运行时间、内存消耗、错误信息等。
  - 生成判题状态码，如通过 (Accepted)、超时 (Time Limit Exceeded)、错误 (Runtime Error) 等。

- **结果返回与存储**：
  - 将判题结果（测试通过情况、运行资源消耗、错误信息）打包发送回后端服务器。
  - 如后端需要，将结果存储到数据库，以便后续查询和统计。

- **日志与监控**：
  - 记录每次判题的日志，包括代码编译和执行日志，用于后续调试和审查。
  - 监控判题服务器的资源使用情况，如 CPU、内存占用率，必要时报警或自动扩容。

### **判题流程简要总结**

1. 用户在前端提交代码。
2. 后端服务器接收代码，将判题任务加入消息队列。
3. 判题服务器监听消息队列，获取任务后编译和执行用户代码。
4. 判题服务器在沙盒环境中执行代码，捕获输出，进行结果比对。
5. 判题服务器将结果发送回后端，后端将判题结果反馈给用户并存储在数据库中。

### **架构图示意**

```plaintext
[User] -> [Frontend] -> [Backend Server] -> [Message Queue] -> [Judging Server]
                                                           -> [Result Storage]
```

通过这种职责划分和流程管理，整个系统可以实现高效、安全的在线判题功能，同时具备良好的扩展性和容错性。

---
1. 通过枚举判断语言
	- 字典树检测敏感词
2. 代码存入文件中
3. 编译代码
4. 运行代码