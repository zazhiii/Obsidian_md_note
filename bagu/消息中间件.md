提供系统之间异步调用，服务与服务之间解耦
# RabbitMQ

## RabbitMQ 如何保证消息不丢失

生产者发送消息到交换机，交换机路由发送消息到队列，消费者从队列消费消息。三个阶段都有可能发生消息丢失。
```txt
		                /--> queue1 --> consumer1 
publisher --> exchange  
						\--> queue2 --> consumer2
```

### 「生产者确认机制」
若消息发送到了队列（queue）中，则会返回 `ack publish-confirm`给发送者，表示消息发送成功；若发送到交换机失败则会返回`nack publish-confirm`，若交换机发送到队列失败会返回`ack publish-return`都表示发送失败。

消息发送失败如何处理？
1. 回调方法直接重发
2. 记录日志
3. 存储到数据库定时重发，发送成功之后删除数据

### 「消息持久化」
1. 交换机持久化
2. 队列持久化
3. 消息持久化

### 「消费者确认机制」

消费者处理消息之后可向 MQ 发送 ack 回执，MQ 收到 ack 之后才会删除该消息。

SpringAMQP 有三种配置确认模式方式：
1. manual：手动 ack，业务代码结束后手动调用 api 发送 ack
2. auto：自动 ack，有 Spring 监测 listener 代码是否有异常，有则返回 nack，无则返回 ack
3. none：关闭 ack，投递消息后立马删除
利用 Spring 的 retry 机制，在消费者出现异常时本地重试，设置重试次数，达到重试次数依然失败的话，则将消息投递到异常交换机，由人工处理。

## RabbitMQ 重复消息问题如何解决

1. 每条消息设置唯一标识 id（优先采用这种方案） 
>在执行业务之前，通过唯一标识查询是否消费过了这个消息。若消费过消息了则直接返回，若没有消费过再执行消费逻辑。

2. 幂等方案：分布式锁、数据锁（乐观锁、悲观锁）

