# 1. 优化

## 1.1 定位慢查询

1. 开启**慢日志查询**，设置值为 2 s，sql 执行超过 2s 就会记录到日志中
2. 使用运维工具（Skywalking)

## 1.2 如何分析慢 sql

在 SQL 语句之前加上关键字 explain / desc，他会给出 SQL 执行的一些信息

`possible_key` 当前 sql 可能会用到的索引
`key` 实际用到的索引
`key_len` 索引占用的大小，与 key二者判断是否命中索引
`Extra` 额外的优化建议
- Using where; Using Index  使用了索引，没有回表查询
- Using index condition  使用了索引，但是需要回表查询 （有优化空间）
![[Pasted image 20250227223158.png]]

1. 通过 key 和 key_len 检查是否命中索引
2. 通过 type 字段查看是否有进一步的优化空间，是否存在全盘扫描或全索引扫描
3. 通过 extra 判断是否存在回表查询；若存在，可尝试添加索引。

# 2. 索引

## 2.1 什么是索引

索引是帮助 MySQL 高效获取数据的数据结构，

## 2.2 索引的数据结构

二叉搜索树缺点：最坏情况会形成链表，查询时间复杂度为。

红黑树缺点：当数据量过多时会导致层级过大，查询效率会降低。

B-Tree：
他是多叉树，每个节点存储 $x$ 个 key ，$x+1$ 个指针

InnoDB 引擎采用 B+ 树存储索引

B+ Tree:
- 每个节点存储 $x$ 个 key ，$x+1$ 个指针
- 数据存储在叶子节点，非叶子节点仅仅提供索引的作用
- 叶子节点形成双向链表
B+树对比B树优点：
1. 磁盘读写代价B+树更低
2. 查询效率更稳定
3. 便于扫库和区间查询（叶子节点是一个双向链表）

## 2.3 聚簇索引和非聚簇索引、回表查询

**聚集索引**：数据与索引存放在一起，索引结构的叶子节点保存行数据，有且只有一个

**非聚集索引（二级索引）**：叶子节点只存储关联的主键，可以有多个

聚集索引的选取规则：
- 若存在主键，选取主键
- 若不存在主键，选取第一个唯一（UNIQUE）索引
- 若不存在主键和唯一索引，InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引

**回表查询**：通过二级索引找到行数据的主键，再用主键通过聚集索引找到行数据的过程。



# 事务
## 事务四大特性（`ACID`）

1. 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
2. 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
3. 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。
4. 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

e.g. 转账案例
## 并发事务问题

赃读：一个事务读到另外一个事务还没有提交的数据。

不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。

幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"。

## 事务隔离级别

1. 读未提交 -- ✅脏读、✅不可重复度、✅幻读

2. 读已提交 -- ❌脏读、✅不可重复读、✅幻读

3. 可重复读 -- ❌脏读、❌不可重复读、✅幻读 **「MySQL默认」**

4. 串行化 -- ❌脏读、❌不可重复读、❌幻读