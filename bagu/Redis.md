
# 基础

## 为什么用Redis

1. 访问速度快 -- 基于内存
2. 高并发 -- QPS 比 MySQL 高一两个数量级
>QPS：Query Per Second 每秒可查询次数
3. 功能强大 -- 缓存、分布式锁、消息队列等等

## 缓存读写策略 TODO

## Redis 的 Java 客户端

- Redission
- Jedis
- lettuce

在项目中使用 SpringDataRedis
# Redis数据类型

## 常见数据类型

String
List
Set
Hash
ZSet

HyperLogLog
Bitmap
Geospatial

## 对象数据用什么类型存储

String 类型整体读写

## Hash 的应用场景

1. 购物车
>key: 用户 ID、field：商品 ID、value：商品数量

## ZSet 排行榜

## ZSet 底层数据结构

跳表

## Set 的应用场景

1. 获取数据集的交、并、差集：共同好友
2. 从数据集中随机获取元素：抽奖、随机点名

# 缓存

## 缓存的更新策略

主动更新 + 超时淘汰兜底

1. 更新缓存还是删除缓存？

❌更新缓存：若数据库更新多次，缓存也会更新多次，若该期间无查询，这些就是无效写
✅删除缓存：更新数据库时直接删除缓存，查询时再新建缓存

2. 如何保证缓存和数据库操作原子性？

- 单体系统：讲缓存和数据库操作放在一个事务中
- 分布式系统：分布式事务

3. 先操作缓存还是先操作数据库？

✅先更新数据库再删缓存
❌先删缓存再更新数据库
>后者操作的间隔时间可能更大（写数据库会较慢），更容易发生并发安全问题。

## 缓存穿透

大量请求数据库不存在的数据，这就导致缓存未命中，导致请求直接打到数据库，造成数据库压力。

解决：
1. 缓存无效的 key
2. 布隆过滤器
>他判断不存在的一定不存在，他判断存在的有可能不存在
3. 接口限流

## 缓存雪崩

缓存雪崩：缓存在同一时间大面积失效，导致大量请求打到数据库，造成数据库压力

解决：
1. 设置随机的失效时间
2. 多级缓存（本地缓存 + Redis 二级缓存）

## 缓存击穿

缓存击穿：热点数据的缓存过期，导致大量请求到数据库。

解决：
1. 加锁：通过设置互斥锁保证只有请求去查询数据库并更新缓存
2. 提前预热：设置热点数据在热点时间内不过期。