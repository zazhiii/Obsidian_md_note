SpringBoot + SpringMVC + Mybatis + Redis + Shiro + RabbitMQ + Docker

**我的职责：**
- 负责技术选型、框架搭建、业务和数据库设计、全流程业务开发、TODO：项目部署。
- 实现密码登录、邮箱验证码登录、 多种登录方式。
- 在系统中实现了基于 Shiro 框架和 JWT 的登录认证与权限控制，并使用全局异常处理器捕获异常。采用 RBAC 模型来管理用户权限。
- 通过 Redis 存储 JWT Token，实现服务端对 Token 的主动控制
- 通过 ThreadLocal 实现了在同一个线程中共享数据。

- 实现了基于**线程池**的异步判题服务，提升了系统的并发处理能力和任务响应速度
- 实现了基于容器池的 Docker 容器复用机制，优化了判题服务的效率，减少了容器创建与销毁的开销，单个任务执行速度提高 84 %

- 实现了基于 Docker 容器的代码执行系统，为用户提交的代码提供隔离、资源管理及安全性保障
- 使用 RabbitMQ 实现后端服务与判题机器之间的高效消息通信
- 使用定时任务自动更新比赛状态，确保系统实时反映比赛进程


---

# 基于 Session 的登录认证

登录：
1. 用户登录请求携带用户名和密码（也可能是其他方式）
2. 后端验证登录信息，若正确则生成一个 Session ID 与用户对应。
3. 将 Session ID 保存会话的 Session 中
请求认证：
4. 客户端将 Session ID 存储再 Cookie 中，每次请求都带上这个 Session ID
5. 服务端查找会话中的 Session ID 信息，如果有效则认为已登录

优点：
1. 简单
缺点：
1. Session 数据会存储在服务器，当用户过多会**造成服务器压力**
2. 分布式环境下每个服务器需要共享 Session 
3. 攻击者获取到 Session ID 可以伪造请求（https 解决）
4. 跨域时浏览器可能不会发送 Session ID
5. 不能实现多设备登录

# 基于 JWT 的登录认证

JWT 主要由三部分组成：

1. **Header（头部）**：通常包含令牌的类型（即 JWT）和签名算法（如 HMAC SHA256 或 RSA）。
2. **Payload（负载）**：包含实际的用户信息（如用户 ID、角色、过期时间等）。Base64编码
3. **Signature（签名）**：服务器使用预定的密钥对 Header 和 Payload 进行签名，确保数据的完整性，防篡改。


优点：
1. 无状态性：不需要服务器再保存信息了。适用于分布式系统。

缺点：
1. 后端不能主动使ta失效
2. Token 过长会影响请求和响应的速度
3. ta有过期时间，需要手动刷新有效期或重新登录，可能导致用户体验中断。


解决后端不能主动使它失效的方案：
1. 维护 token 黑名单 （分布式下会有问题，也可能影响性能）
2. Redis 存储 token 


# 什么RBAC？

Role-Based Access Control，基于角色（Role）的访问控制。
将权限分配给角色，再将角色分配给用户。

[RBAC——基于角色权限的模型-CSDN博客](https://blog.csdn.net/m0_62006803/article/details/133962328) 详细介绍


# 容器池的实现

基于阻塞队列